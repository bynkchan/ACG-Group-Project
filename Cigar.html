<!DOCTYPE html>
<html lang="en">
	<head>
		<meta charset="utf-8">
		<title>Smoking cigar</title>
		<author>Erich Doclaf 5121FG93</author>
		<style>
			body { margin: 0; }
		</style>
	</head>
	<body>

        <!-- Fragment shader program 
        <script id="fragmentShader" type="x-shader/x-fragment">
            precision mediump float;
			precision mediump int;

			uniform float time;

			varying vec3 vPosition;
			varying vec4 vColor;

			void main()	{

				vec4 color = vec4( vColor );
				color.r += sin( vPosition.x * 10.0 + time ) * 0.5;

				gl_FragColor = color;

			}
        </script>
        -->

        <!-- Vertex shader program 
        <script id="vertexSahder" type="x-shader/x-vertex">
            precision mediump float;
			precision mediump int;

			uniform mat4 modelViewMatrix; // optional
			uniform mat4 projectionMatrix; // optional

			attribute vec3 position;
			attribute vec4 color;

			varying vec3 vPosition;
			varying vec4 vColor;

			void main()	{

				vPosition = position;
				vColor = color;

				gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );

			}
        </script>
        -->
        
        <!--
        <script src="js/three.js"></script>
        -->


		<script type="module">
            
            import * as THREE from './js/three.module.js';
            import { OrbitControls } from './js/OrbitControls.js';
            import { GLTFLoader } from './js/GLTFLoader.js';

            let scene, camera, loader, renderer, light, obj, position, mesh; 
            //const particleCount = 500;
            
            init();
            initControls()
            animate(); //render();


			function init() {
                
                scene = new THREE.Scene();
                light = new THREE.HemisphereLight( 0xffffff, 0x000000, 5 );
                scene.add( light );
                scene.background = new THREE.Color('white');
                scene.fog = new THREE.Fog(0x5d0361, 10, 1500);

                camera = new THREE.PerspectiveCamera( 75, window.innerWidth / window.innerHeight, 0.1, 1000 );
                camera.position.set( 30, 15, 15 );
                //camera.position.z = 20;

                renderer = new THREE.WebGLRenderer();
                renderer.setSize( window.innerWidth, window.innerHeight );
                document.body.appendChild( renderer.domElement );

                loader = new GLTFLoader();

                // Loading of cigar as gltf object
                loader.load( './cigar/scene.gltf', function ( gltf ) {
                    
                    obj = gltf.scene;
                    obj.position.z = -7.2
                    obj.position.y = -2.7
                    scene.add( obj );
                    
                    
                    console.log("Coordinates of the cigar", obj.position);

                }, undefined, function ( error ) {

                    console.error( error );

                } );
                
                //Grid
                const gridHelper = new THREE.GridHelper(200, 50);
                scene.add( gridHelper )


                //Smoke
                const triangles = 1500;

				const geometry = new THREE.BufferGeometry();

				const positions = [];
				const normals = [];
				const colors = [];

				const color = new THREE.Color();

				const n = 8, n2 = n / 1;	// triangles spread in the cube
				const d = 0.2, d2 = d / 2;	// individual triangle size

				const pA = new THREE.Vector3();
				const pB = new THREE.Vector3();
				const pC = new THREE.Vector3();

				const cb = new THREE.Vector3();
				const ab = new THREE.Vector3();

				for ( let i = 0; i < triangles; i ++ ) {

					// positions
                    const shift = 16
					const x = Math.random() * n2/shift - n2/(shift*2);
					const y = Math.random() * n*2;
					const z = Math.random() * n/128;

					const ax = x + Math.random() * d;
					const ay = y + Math.random() * d;
					const az = z + Math.random() * d;

					const bx = x + Math.random() * d - d2;
					const by = y + Math.random() * d - d2;
					const bz = z + Math.random() * d - d2;

					const cx = x + Math.random() * d - d2;
					const cy = y + Math.random() * d - d2;
					const cz = z + Math.random() * d - d2;

					positions.push( ax, ay, az );
					positions.push( bx, by, bz );
					positions.push( cx, cy, cz );

					// flat face normals

					pA.set( ax, ay, az );
					pB.set( bx, by, bz );
					pC.set( cx, cy, cz );

					cb.subVectors( pC, pB );
					ab.subVectors( pA, pB );
					cb.cross( ab );

					cb.normalize();

					const nx = cb.x;
					const ny = cb.y;
					const nz = cb.z;

					normals.push( nx, ny, nz );
					normals.push( nx, ny, nz );
					normals.push( nx, ny, nz );

					// colors

					//const vx = ( x / n ) + 0.5;
					//const vy = ( y / n ) + 0.5;
					//const vz = ( z / n ) + 0.5;
                    const vx = 0.5, vy = 0.5, vz = 0.5;
					color.setRGB( vx, vy, vz );

					const alpha = Math.random();

					colors.push( color.r, color.g, color.b, alpha );
					colors.push( color.r, color.g, color.b, alpha );
					colors.push( color.r, color.g, color.b, alpha );

				}

                function disposeArray() {

                    this.array = null;

                }


                geometry.setAttribute( 'position', new THREE.Float32BufferAttribute( positions, 3 ).onUpload( disposeArray ) );
				geometry.setAttribute( 'normal', new THREE.Float32BufferAttribute( normals, 3 ).onUpload( disposeArray ) );
				geometry.setAttribute( 'color', new THREE.Float32BufferAttribute( colors, 4 ).onUpload( disposeArray ) );

				geometry.computeBoundingSphere();

				const material = new THREE.MeshPhongMaterial( {
					color: 0xaaaaaa, specular: 0xffffff, shininess: 250,
					side: THREE.DoubleSide, vertexColors: true, transparent: true
				} );

                mesh = new THREE.Mesh( geometry, material );
				scene.add( mesh );
            }


            function initControls() {
                const controls = new OrbitControls(camera, renderer.domElement);
                controls.target.set( 0, 0, 0 );
                controls.enableDamping = true;
                //controls.dampingFactor = 0.25;
                controls.enableZoom = true;
                controls.autoRotate = false;
                controls.autoRotateSpeed = 0.5;
                controls.minDistance = 1;
                controls.maxDistance = 2000;
                controls.enablePan = true;
            }

            
            function animate() {
	            requestAnimationFrame( animate );
                //if(obj) obj.rotation.y += 0.002;

                render();
            }


            function render() {
                const time = Date.now() * 0.005;
                
                mesh.rotation.y = time * 10;
				//mesh.material.uniforms.time.value = time * 0.005;
                
	            renderer.render( scene, camera );
            }
            /*
            const geometry1 = new THREE.BoxGeometry( 0.1, 0.1, 0.1 );
            const material = new THREE.MeshBasicMaterial( { color: 0xffff00 } );
            const mesh = new THREE.Mesh( geometry1, material );
            mesh.position.z = +0.1
            scene.add( mesh );
            //scene.updateMatrixWorld(true);
            //let position = new THREE.Vector3();
            //position.setFromMatrixPosition( mesh.matrixWorld );        
            
            //if(obj) console.log(obj.rotation.y);
            //*/

            
		</script>
	</body>
</html>