<!DOCTYPE html>
<html lang="en">
	<head>
		<meta charset="utf-8">
		<title>Magnifying Glass</title>
		<author>Akirabha Chanuntranont 5121DG04-3</author>
		<style>
			body { margin: 0; }
		</style>
	</head>
	<body>
        <script src="js/three.js"></script>
		<script type="module">
			/*
			This code makes use of functions and shapes from the three.js library, whose documentation is available at this link:  https://threejs.org/docs
			*/
			// Initialize the scene
            const scene = new THREE.Scene();
			const bgTexture = new THREE.TextureLoader().load('textures/test_box/crt.jpg');
			const bgGeometry = new THREE.PlaneGeometry(18, 10);
			const bgMaterial = new THREE.MeshBasicMaterial({ map: bgTexture });
			const bgMesh = new THREE.Mesh(bgGeometry, bgMaterial);
			bgMesh.position.set(0, 0, -1);
			scene.add(bgMesh);


			// Lighting
			const directionalLight = new THREE.DirectionalLight( { 
				color: 0xffffff, 
				intensity: 0.8 
			} );
			scene.add( directionalLight );
			directionalLight.position.x = 0.0;
			directionalLight.position.y = 1.0;
			directionalLight.position.z = 0.0;


			// Set rendering properties
			const camera = new THREE.PerspectiveCamera( 75, window.innerWidth / window.innerHeight, 0.1, 1000 );
			const renderer = new THREE.WebGLRenderer();
			renderer.setSize( window.innerWidth, window.innerHeight );
			document.body.appendChild( renderer.domElement );
			camera.position.z = 5;


			// Make the glass lens
			const lensradius = 1.0;
			const GlassGeometry = new THREE.SphereGeometry(lensradius); // Begin with a sphere
			GlassGeometry.applyMatrix( new THREE.Matrix4().makeScale( 1.0, 1.0, 0.4 ) ); // Apply transformation matrix to turn it into an ellipsoid
			const GlassMaterial = new THREE.MeshPhysicalMaterial( { // Physical rendering
				roughness: 0,  // Roughness of the surface
				transmission: 1,  // Light transmission through the surface
				thickness: 1, // Thickness (density?) of the glass, affects refraction
				reflectivity: 0.2, // Reflectivity of the glass, affects refraction
				ior: 1.5, // Index of Refraction
				clearcoat: 0.5 // Reflective laquer coating
			} );
			const Glass = new THREE.Mesh( GlassGeometry, GlassMaterial );


			// Make the lens rim
			const xrimcenter = 0;
			const yrimcenter = 0;
			const rimradius = lensradius;
			const rimdepth = 0.7;
			const OuterRim = new THREE.Shape();
			OuterRim.absarc(
				xrimcenter,   // x-center
				yrimcenter,   // y-center
				rimradius,   // radius
				0,   // start angle
				Math.PI*1.99, // end angle (must overlap to avoid clipping)
				false  // sweep arc clockwise?
			);
			const InnerRim = new THREE.Path();
			InnerRim.absarc(
				xrimcenter,   // x-center
				yrimcenter,   // y-center
				rimradius*0.9,   // radius
				0,   // start angle
				Math.PI*2.01, // end angle (must overlap to avoid clipping)
				true  // sweep arc clockwise?
			);
			OuterRim.holes.push(InnerRim);
			const RimExtrudeSettings = {
				steps: 1,
				depth: rimdepth,
				bevelEnabled: true,
				bevelThickness: 0.05,
				bevelSize: 0.07,
				bevelOffset: 0,
				bevelSegments: 100,
				curveSegments: 500
			};
			const RimGeometry = new THREE.ExtrudeGeometry(OuterRim, RimExtrudeSettings);
			const RimMaterial = new THREE.MeshPhysicalMaterial({ // Physical rendering
				color: 0xffffff,
        		metalness: 1.0,
				roughness: 0.4,
        		clearcoat: 1.0,
        		envMap: bgTexture
    		});
			const Rim = new THREE.Mesh( RimGeometry, RimMaterial );
			Rim.position.z = -rimdepth/2.0; // Center ring in middle of lens for extrusion


			// Make handle
			const linkradius = rimdepth/2.7;
			const tube = linkradius*0.5;
			const ylinkpos = -rimradius-tube*0.8; // Move link down to edge of rim
			const handleLength = rimradius*1.3;
			const handleGirth = linkradius;
			const yhandlepos = (ylinkpos)-(handleLength/1.3); // Move handle down to be in line with link
			const LinkGeometry = new THREE.TorusGeometry( linkradius, tube, 20, 100 );
			const LinkMaterial = new THREE.MeshPhysicalMaterial({ // Physical rendering
				color: 0xffffff,
        		metalness: 1.0,
				roughness: 0.4,
        		clearcoat: 1.0,
        		envMap: bgTexture
    		});
			const Link = new THREE.Mesh( LinkGeometry, LinkMaterial ); // Metal link between handle and rim
			Link.position.y = ylinkpos; // Move link down to edge of rim
			Link.rotation.x = Math.PI/2; // Rotate to put it in the plane of the rim
			const HandleGeometry = new THREE.SphereGeometry(handleLength); // Begin with a sphere
			HandleGeometry.applyMatrix( new THREE.Matrix4().makeScale( 0.25, 1.0, 0.25 ) ); // Apply transformation matrix to turn it into an ellipsoid
			const HandleMaterial = new THREE.MeshPhysicalMaterial({ // Physical rendering
				color: 0xffffff,
        		metalness: 1.0,
				roughness: 0.4,
        		clearcoat: 1.0,
        		envMap: bgTexture
    		});
			const Handle = new THREE.Mesh( HandleGeometry, HandleMaterial );
			Handle.position.y = yhandlepos  // Move handle down to be in line with link


			// Group objects to make a magnifying glass
			const MagnifyingGlass = new THREE.Object3D();  // Generic container for three object class
			MagnifyingGlass.add(Glass); // Add the glass lens to the magnifying glass
			MagnifyingGlass.add(Rim); // Add the rim to the magnifying glass
			MagnifyingGlass.add(Link); // Add the link to the magnifying glass
			MagnifyingGlass.add(Handle); // Add the handle to the magnifying glass
			MagnifyingGlass.position.y = 0.8;
			scene.add(MagnifyingGlass);


			// Animate the scene
			function animate() {
				requestAnimationFrame( animate );
				MagnifyingGlass.rotation.x += 0.00;
				MagnifyingGlass.rotation.y += 0.01;
				Handle.rotation.y += 0.01;
				renderer.render( scene, camera );
			};
			animate();
		</script>
	</body>
</html>