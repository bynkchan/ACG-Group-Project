<!DOCTYPE html>
<html lang="en">
	<head>
		<meta charset="utf-8">
		<title>Magnifying Glass</title>
		<author>Akirabha Chanuntranont 5121DG04-3</author>
		<style>
			body { margin: 0; }
		</style>
	</head>
	<body>
        <script src="js/three.js"></script>
		<script type="module">
			/*
			This code makes use of functions and shapes from the three.js library, whose documentation is available at this link:  https://threejs.org/docs
			*/
			// import { GLTFLoader } from './js/GLTFLoader.js';

			// Global variables
			window.addEventListener('load', init)
			let scene
			let bgTexture
			let camera
			let renderer
			let sceneobjects = []

			// Initialize the scene
			function init(){
				scene = new THREE.Scene();
				bgTexture = new THREE.TextureLoader().load('textures/test_box/crt.jpg');
				let bgGeometry = new THREE.PlaneGeometry(18, 10);
				let bgMaterial = new THREE.MeshBasicMaterial({ map: bgTexture });
				let bgMesh = new THREE.Mesh(bgGeometry, bgMaterial);
				bgMesh.position.set(0, 0, -1);
				scene.add(bgMesh);
				setlighting()
				setcamera()
				addMagnifyingGlass()
				animate()
			}

			// Define vertex shader
			function vertexShader() {
  				return `
    				varying vec3 vUv; 

    				void main() {
      					vUv = position; 

      					vec4 modelViewPosition = modelViewMatrix * vec4(position, 1.0);
      					gl_Position = projectionMatrix * modelViewPosition; 
    				}
  				`
			}

			// Define fragment shader
			function fragmentShader() {
				return `
      				uniform vec3 colorA; 
      				uniform vec3 colorB; 
      				varying vec3 vUv;

      				void main() {
       	 				gl_FragColor = vec4(mix(colorA, colorB, vUv.z), 1.0);
      				}
  				`
			}

			// Lighting
			function setlighting(){
				const directionalLight = new THREE.DirectionalLight( { 
				color: 0xffffff, 
				intensity: 0.8 
				} );
				scene.add( directionalLight );
				directionalLight.position.x = 0.0;
				directionalLight.position.y = 1.0;
				directionalLight.position.z = 0.0;
			}
			
			// Set camera properties
			function setcamera(){
				camera = new THREE.PerspectiveCamera( 75, window.innerWidth / window.innerHeight, 0.1, 1000 );
				renderer = new THREE.WebGLRenderer();
				renderer.setSize( window.innerWidth, window.innerHeight );
				document.body.appendChild( renderer.domElement );
				camera.position.z = 5;
			}

			// Custom materials
			const woodmaterial = new THREE.ShaderMaterial( {
				uniforms: {
					time: { value: 1.0 },
					resolution: { value: new THREE.Vector3() }
				},
				vertexShader: document.getElementById( 'vertexShader' ).textContent,
				fragmentShader: document.getElementById( 'fragmentShader' ).textContent
			} );

			// Make the magnifying glass
			function addMagnifyingGlass(){
				// Make the glass lens
				const lensradius = 1.0;
				const GlassGeometry = new THREE.SphereGeometry(lensradius); // Begin with a sphere
				GlassGeometry.applyMatrix( new THREE.Matrix4().makeScale( 1.0, 1.0, 0.4 ) ); // Apply transformation matrix to turn it into an ellipsoid
				const GlassMaterial = new THREE.MeshPhysicalMaterial( { // Physical rendering
					roughness: 0,  // Roughness of the surface
					transmission: 1,  // Light transmission through the surface
					thickness: 1, // Thickness (density?) of the glass, affects refraction
					reflectivity: 0.2, // Reflectivity of the glass, affects refraction
					ior: 1.5, // Index of Refraction
					clearcoat: 0.5 // Reflective laquer coating
				} );
				const Glass = new THREE.Mesh( GlassGeometry, GlassMaterial );

				// Make the lens rim
				const xrimcenter = 0;
				const yrimcenter = 0;
				const rimradius = lensradius;
				const rimdepth = 0.7;
				const OuterRim = new THREE.Shape();
				OuterRim.absarc(
					xrimcenter,   // x-center
					yrimcenter,   // y-center
					rimradius,   // radius
					0,   // start angle
					Math.PI*1.99, // end angle (must overlap to avoid clipping)
					false  // sweep arc clockwise?
				);
				const InnerRim = new THREE.Path();
				InnerRim.absarc(
					xrimcenter,   // x-center
					yrimcenter,   // y-center
					rimradius*0.9,   // radius
					0,   // start angle
					Math.PI*2.01, // end angle (must overlap to avoid clipping)
					true  // sweep arc clockwise?
				);
				OuterRim.holes.push(InnerRim);
				const RimExtrudeSettings = {
					steps: 1,
					depth: rimdepth,
					bevelEnabled: true,
					bevelThickness: 0.05,
					bevelSize: 0.07,
					bevelOffset: 0,
					bevelSegments: 100,
					curveSegments: 500
				};
				const RimGeometry = new THREE.ExtrudeGeometry(OuterRim, RimExtrudeSettings);
				const RimMaterial = new THREE.MeshPhysicalMaterial({ // Physical rendering
					color: 0xffffff,
        			metalness: 1.0,
					roughness: 0.4,
        			clearcoat: 1.0,
        			envMap: bgTexture
    			});
				const Rim = new THREE.Mesh( RimGeometry, RimMaterial );
				Rim.position.z = -rimdepth/2.0; // Center ring in middle of lens for extrusion

				// Make handle
				const linkradius = rimdepth/2.7;
				const tube = linkradius*0.5;
				const ylinkpos = -rimradius-tube*0.8; // Move link down to edge of rim
				const handleLength = rimradius*1.3;
				const handleGirth = linkradius;
				const yhandlepos = (ylinkpos)-(handleLength/1.3); // Move handle down to be in line with link
				const LinkGeometry = new THREE.TorusGeometry( linkradius, tube, 20, 100 );
				const LinkMaterial = new THREE.MeshPhysicalMaterial({ // Physical rendering
					color: 0xffffff,
        			metalness: 1.0,
					roughness: 0.4,
        			clearcoat: 1.0,
        			envMap: bgTexture
    			});
				const Link = new THREE.Mesh( LinkGeometry, LinkMaterial ); // Metal link between handle and rim
				Link.position.y = ylinkpos; // Move link down to edge of rim
				Link.rotation.x = Math.PI/2; // Rotate to put it in the plane of the rim
				const HandleGeometry = new THREE.SphereGeometry(handleLength); // Begin with a sphere
				HandleGeometry.applyMatrix( new THREE.Matrix4().makeScale( 0.25, 1.0, 0.25 ) ); // Apply transformation matrix to turn it into an ellipsoid
				const HandleMaterial = new THREE.MeshPhysicalMaterial({ // Physical rendering
					color: 0xffffff,
        			metalness: 1.0,
					roughness: 0.4,
        			clearcoat: 1.0,
        			envMap: bgTexture
    			});
				const Handle = new THREE.Mesh( HandleGeometry, HandleMaterial );
				Handle.position.y = yhandlepos  // Move handle down to be in line with link

				// Group objects to make a magnifying glass
				const MagnifyingGlass = new THREE.Object3D();  // Generic container for three object class
				MagnifyingGlass.add(Glass); // Add the glass lens to the magnifying glass
				MagnifyingGlass.add(Rim); // Add the rim to the magnifying glass
				MagnifyingGlass.add(Link); // Add the link to the magnifying glass
				MagnifyingGlass.add(Handle); // Add the handle to the magnifying glass
				MagnifyingGlass.position.y = 0.8;
				scene.add(MagnifyingGlass);

				sceneobjects.push(MagnifyingGlass) // Add magnifying glass to scene objects

			}


			


			// Animate the scene
			function animate() {
				requestAnimationFrame( animate );
				sceneobjects[0].rotation.x += 0.00;
				sceneobjects[0].rotation.y += 0.01;
				renderer.render( scene, camera );
			};
			//animate();
		</script>
	</body>
</html>